{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["import fs from \"fs\";\r\nimport path from \"path\";\r\nimport checkDiskSpace from \"check-disk-space\";\r\nimport { createHash } from \"crypto\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { dotExtensionToCategotry, sfsFileType } from \"sfs-file-type\";\r\nimport { fileTypeFromBuffer } from \"file-type\";\r\n\r\nexport interface UploadedFile {\r\n  /** file name */\r\n  name: string;\r\n  /** A function to move the file elsewhere on your server */\r\n  mv(path: string, callback: (err: any) => void): void;\r\n  mv(path: string): Promise<void>;\r\n  /** Encoding type of the file */\r\n  encoding: string;\r\n  /** The mimetype of your file */\r\n  mimetype: string;\r\n  /** A buffer representation of your file, returns empty buffer in case useTempFiles option was set to true. */\r\n  data: Buffer;\r\n  /** Uploaded size in bytes */\r\n  size: number;\r\n  /** MD5 checksum of the uploaded file */\r\n  md5: string;\r\n}\r\nexport type sfsFileId = string | number;\r\nexport type sfsFile = {\r\n  id: sfsFileId;\r\n  name: string;\r\n  extension: string;\r\n  hash: string;\r\n  size: number; //Bytes\r\n  type: sfsFileType;\r\n  last_modified: number; //timestamp,\r\n  path: string;\r\n  url?: string;\r\n};\r\nexport type loggerLvl = \"info\" | \"success\" | \"error\";\r\n/**\r\n * Configuration for Simple File Storage (SFS)\r\n */\r\nexport type sfsConfig = {\r\n  /**\r\n   * Folder where files will be stored.\r\n   */\r\n  publicFolder: string;\r\n\r\n  /**\r\n   * Base URL prefix to which the file ID will be appended.\r\n   */\r\n  mask: string;\r\n\r\n  /**\r\n   * Function that returns an `sfsFile` based on its ID.\r\n   * @param id - The file's unique identifier.\r\n   * @returns A promise resolving to the corresponding `sfsFile`.\r\n   */\r\n  getFileById: (id: sfsFileId) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Function that returns an `sfsFile` based on its content hash.\r\n   * @param hash - The hash of the file contents.\r\n   * @returns A promise resolving to the corresponding `sfsFile`.\r\n   */\r\n  getFileByHash: (hash: string) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Function that stores an `sfsFile` and returns the stored object.\r\n   * @param file - The `sfsFile` to be created.\r\n   * @returns A promise resolving to the stored `sfsFile`.\r\n   */\r\n  createFile: (file: sfsFile) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Optional logger function. Leave undefined to disable logging.\r\n   * @param message - Log message or object.\r\n   * @param lvl - Optional log level (e.g., info, warn, error).\r\n   */\r\n  logger?: (message: any, lvl?: loggerLvl) => void;\r\n\r\n  /**\r\n   * Optional function for generating unique IDs.\r\n   * Defaults to `uuidv4()` if not provided.\r\n   * @returns A unique string or number.\r\n   */\r\n  uid?: () => string | number;\r\n\r\n  allowDuplicates?: boolean;\r\n};\r\n\r\n/**\r\n * Initializes core logic functions for the Simple File Storage (SFS) system.\r\n *\r\n * @param config - The configuration object for the SFS system.\r\n * @param config.publicFolder - Path to the folder where uploaded files will be stored.\r\n * @param config.mask - Base URL prefix for constructing public file URLs (e.g., \"https://example.com/files\").\r\n * @param config.getFileById - Async function that retrieves an `sfsFile` by its unique ID.\r\n * @param config.getFileByHash - Async function that retrieves an `sfsFile` by its content hash.\r\n * @param config.createFile - Async function that stores an `sfsFile` and returns the stored object.\r\n * @param config.logger - Optional logger function for internal operations. No logging if undefined.\r\n * @param config.uid - Optional function for generating unique IDs (defaults to `uuidv4` if not provided).\r\n * @param config.allowDuplicates - Flag deterining whether to allow storing duplicate files in database, important for clientside optimistic uploads\r\n *\r\n * @returns An object containing internal logic functions used by the SFS system.\r\n */\r\n\r\n//TODO  Turn it into a class\r\nexport default function initFunctions({\r\n  publicFolder,\r\n  mask,\r\n  getFileById,\r\n  getFileByHash,\r\n  createFile,\r\n  logger = undefined,\r\n  uid = uuidv4,\r\n  allowDuplicates = false,\r\n}: sfsConfig) {\r\n  /**\r\n   * Converts a URL to its corresponding file ID by removing the mask prefix.\r\n   * Handles cases where the mask may or may not end with a slash.\r\n   *\r\n   * @param url - The URL string to convert.\r\n   * @returns The extracted file ID from the URL.\r\n   */\r\n  const urlToId = (url: string) =>\r\n    mask.endsWith(\"/\") ? url.replace(mask, \"\") : url.replace(mask + \"/\", \"\");\r\n\r\n  /**\r\n   * Converts a file ID to its corresponding URL by prepending the mask prefix.\r\n   * Handles cases where the mask may or may not end with a slash.\r\n   *\r\n   * @param id - The file ID to convert to a URL.\r\n   * @returns The constructed URL string for the given file ID.\r\n   */\r\n  const idToUrl = (id: sfsFileId) =>\r\n    (mask.endsWith(\"/\") ? mask : mask + \"/\") + id;\r\n\r\n  /**\r\n   * Resolves the absolute file system path and original name of a stored file by its ID.\r\n   *\r\n   * This function retrieves metadata for the given file ID using `getFileById`,\r\n   * and constructs the full path to the file in the `publicFolder`, based on its hash and extension.\r\n   *\r\n   * @param id - The unique identifier of the stored file.\r\n   * @returns An object containing the full file system path (`filePath`) and original file name (`fileName`),\r\n   *          or `undefined` if the file was not found.\r\n   */\r\n  const resolveFilePath = async (id: sfsFileId) => {\r\n    const fileInfo = await getFileById(id);\r\n    if (fileInfo) {\r\n      const { hash, extension, name } = fileInfo;\r\n      const filePath = hash + extension;\r\n      return { filePath: path.join(publicFolder, filePath), fileName: name };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles upload and deduplication logic for a single file.\r\n   *\r\n   * - Calculates SHA-256 hash of the file content in-memory.\r\n   * - Determines file extension from name or infers from binary data.\r\n   * - Avoids storing duplicates by using `hash + extension` as unique filename.\r\n   * - Saves file to disk if not already stored.\r\n   * - Registers file metadata via `createFile`, or reuses existing entry.\r\n   *\r\n   * @param file - Uploaded file object (e.g., from express-fileupload).\r\n   * @param filePath - Logical file path (or folder-relative path) for storing metadata.\r\n   * @returns An `sfsFile` object with generated ID and public URL.\r\n   *\r\n   * @throws Will throw if file saving or metadata operations fail.\r\n   */\r\n\r\n  // TODO | ALL properties other than file shouls be optional\r\n  // TODO | Reimplement temp folder for hash calculation\r\n  // TODO | Support user defined hashing methods\r\n\r\n  const saveFile = async (\r\n    file: UploadedFile,\r\n    filePath: string = \"/\",\r\n    id: sfsFileId = uid()\r\n  ) => {\r\n    try {\r\n      // Save file\r\n      const name = decodeURI(file.name);\r\n      const hash = createHash(\"sha256\").update(file.data).digest(\"hex\");\r\n      // Get extenison\r\n      let extension = \"\";\r\n      const extensionFromName = path.extname(name);\r\n      if (extensionFromName) {\r\n        extension = extensionFromName;\r\n      } else {\r\n        const filetype = await fileTypeFromBuffer(file.data);\r\n        if (filetype) {\r\n          extension = `.${filetype.ext}`;\r\n        }\r\n      }\r\n      // Filename is its hash + extension to avoid storing duplicate files with different names\r\n      const constPath = path.join(publicFolder, hash + extension);\r\n      let fileInfo = await getFileByHash(hash);\r\n\r\n      // File exists\r\n      if (fileInfo) {\r\n        logger && logger(\"SFS: File already uploaded\", \"info\");\r\n      }\r\n      // File is new\r\n      else {\r\n        logger && logger(\"SFS: Saving file\", \"success\");\r\n        await file.mv(constPath);\r\n      }\r\n      // File is new or doesnt exist in this folder or duplocates are allowed\r\n      if (!!!fileInfo || filePath !== fileInfo.path || allowDuplicates) {\r\n        const size = fileInfo?.size || fs.statSync(constPath).size;\r\n        const type = fileInfo?.type || dotExtensionToCategotry(extension);\r\n        const now = Date.now();\r\n        const fileData = {\r\n          id,\r\n          name,\r\n          extension,\r\n          hash,\r\n          size,\r\n          type,\r\n          last_modified: now,\r\n          path: filePath,\r\n          publishedAt: now,\r\n        };\r\n\r\n        const mutationResult = await createFile(fileData);\r\n\r\n        mutationResult.url = idToUrl(mutationResult.id);\r\n\r\n        return mutationResult;\r\n      }\r\n\r\n      // File exists in this folder\r\n      else {\r\n        logger && logger(\"File already exists at this location\", \"error\");\r\n        fileInfo.url = idToUrl(fileInfo.id);\r\n\r\n        return fileInfo;\r\n      }\r\n    } catch (err) {\r\n      logger && logger(\"Upload error\", \"error\");\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const deleteFileByHash = async (hash: string) => {\r\n    try {\r\n      const files = fs.readdirSync(publicFolder);\r\n      const fileToDelete = files.find((f) => f.split(\".\")[0] === hash);\r\n      if (!fileToDelete) {\r\n        throw new Error(`File with hash ${hash} not found in ${publicFolder}`);\r\n      }\r\n      const pathToFile = path.join(publicFolder, fileToDelete);\r\n      fs.unlinkSync(pathToFile);\r\n    } catch (err) {\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const deleteFileById = async (id: string) => {\r\n    try {\r\n      const { filePath } = await resolveFilePath(id);\r\n      fs.unlinkSync(filePath);\r\n    } catch (err) {\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const getDiskUsage = async (req, res) => {\r\n    const diskSpace = await checkDiskSpace(publicFolder);\r\n    return diskSpace;\r\n  };\r\n  return {\r\n    resolveFilePath,\r\n    idToUrl,\r\n    urlToId,\r\n    saveFile,\r\n    deleteFileByHash,\r\n    deleteFileById,\r\n    getDiskUsage,\r\n  };\r\n}\r\n"],"names":["_ref","publicFolder","mask","getFileById","getFileByHash","createFile","_ref$logger","logger","undefined","_ref$uid","uid","uuidv4","_ref$allowDuplicates","allowDuplicates","idToUrl","id","endsWith","resolveFilePath","Promise","resolve","then","fileInfo","name","filePath","path","join","hash","extension","fileName","e","reject","urlToId","url","replace","saveFile","file","_catch","_temp4","constPath","_temp2","size","fs","statSync","type","dotExtensionToCategotry","now","Date","last_modified","publishedAt","mutationResult","_temp","mv","decodeURI","createHash","update","data","digest","extensionFromName","extname","_temp3","fileTypeFromBuffer","filetype","ext","err","Error","deleteFileByHash","fileToDelete","readdirSync","find","f","split","pathToFile","unlinkSync","deleteFileById","_ref2","getDiskUsage","req","res","checkDiskSpace"],"mappings":"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"}