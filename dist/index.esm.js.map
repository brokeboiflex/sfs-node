{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import fs from \"fs\";\r\nimport path from \"path\";\r\nimport checkDiskSpace from \"check-disk-space\";\r\nimport { createHash } from \"crypto\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { dotExtensionToCategotry, sfsFileType } from \"sfs-file-type\";\r\nimport { fileTypeFromBuffer } from \"file-type\";\r\n\r\nexport interface UploadedFile {\r\n  /** file name */\r\n  name: string;\r\n  /** A function to move the file elsewhere on your server */\r\n  mv(path: string, callback: (err: any) => void): void;\r\n  mv(path: string): Promise<void>;\r\n  /** Encoding type of the file */\r\n  encoding: string;\r\n  /** The mimetype of your file */\r\n  mimetype: string;\r\n  /** A buffer representation of your file, returns empty buffer in case useTempFiles option was set to true. */\r\n  data: Buffer;\r\n  /** Uploaded size in bytes */\r\n  size: number;\r\n  /** MD5 checksum of the uploaded file */\r\n  md5: string;\r\n}\r\nexport type sfsFileId = string | number;\r\nexport type sfsFile = {\r\n  id: sfsFileId;\r\n  name: string;\r\n  extension: string;\r\n  hash: string;\r\n  size: number; //Bytes\r\n  type: sfsFileType;\r\n  last_modified: number; //timestamp,\r\n  path: string;\r\n  url?: string;\r\n};\r\nexport type loggerLvl = \"info\" | \"success\" | \"error\";\r\n/**\r\n * Configuration for Simple File Storage (SFS)\r\n */\r\nexport type sfsConfig = {\r\n  /**\r\n   * Folder where files will be stored.\r\n   */\r\n  publicFolder: string;\r\n\r\n  /**\r\n   * Base URL prefix to which the file ID will be appended.\r\n   */\r\n  mask: string;\r\n\r\n  /**\r\n   * Function that returns an `sfsFile` based on its ID.\r\n   * @param id - The file's unique identifier.\r\n   * @returns A promise resolving to the corresponding `sfsFile`.\r\n   */\r\n  getFileById: (id: sfsFileId) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Function that returns an `sfsFile` based on its content hash.\r\n   * @param hash - The hash of the file contents.\r\n   * @returns A promise resolving to the corresponding `sfsFile`.\r\n   */\r\n  getFileByHash: (hash: string) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Function that stores an `sfsFile` and returns the stored object.\r\n   * @param file - The `sfsFile` to be created.\r\n   * @returns A promise resolving to the stored `sfsFile`.\r\n   */\r\n  createFile: (file: sfsFile) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Optional logger function. Leave undefined to disable logging.\r\n   * @param message - Log message or object.\r\n   * @param lvl - Optional log level (e.g., info, warn, error).\r\n   */\r\n  logger?: (message: any, lvl?: loggerLvl) => void;\r\n\r\n  /**\r\n   * Optional function for generating unique IDs.\r\n   * Defaults to `uuidv4()` if not provided.\r\n   * @returns A unique string or number.\r\n   */\r\n  uid?: () => string | number;\r\n\r\n  allowDuplicates?: boolean;\r\n};\r\n\r\n/**\r\n * Initializes core logic functions for the Simple File Storage (SFS) system.\r\n *\r\n * @param config - The configuration object for the SFS system.\r\n * @param config.publicFolder - Path to the folder where uploaded files will be stored.\r\n * @param config.mask - Base URL prefix for constructing public file URLs (e.g., \"https://example.com/files\").\r\n * @param config.getFileById - Async function that retrieves an `sfsFile` by its unique ID.\r\n * @param config.getFileByHash - Async function that retrieves an `sfsFile` by its content hash.\r\n * @param config.createFile - Async function that stores an `sfsFile` and returns the stored object.\r\n * @param config.logger - Optional logger function for internal operations. No logging if undefined.\r\n * @param config.uid - Optional function for generating unique IDs (defaults to `uuidv4` if not provided).\r\n * @param config.allowDuplicates - Flag deterining whether to allow storing duplicate files in database, important for clientside optimistic uploads\r\n *\r\n * @returns An object containing internal logic functions used by the SFS system.\r\n */\r\n\r\n//TODO  Turn it into a class\r\nexport default function initFunctions({\r\n  publicFolder,\r\n  mask,\r\n  getFileById,\r\n  getFileByHash,\r\n  createFile,\r\n  logger = undefined,\r\n  uid = uuidv4,\r\n  allowDuplicates = false,\r\n}: sfsConfig) {\r\n  /**\r\n   * Converts a URL to its corresponding file ID by removing the mask prefix.\r\n   * Handles cases where the mask may or may not end with a slash.\r\n   *\r\n   * @param url - The URL string to convert.\r\n   * @returns The extracted file ID from the URL.\r\n   */\r\n  const urlToId = (url: string) =>\r\n    mask.endsWith(\"/\") ? url.replace(mask, \"\") : url.replace(mask + \"/\", \"\");\r\n\r\n  /**\r\n   * Converts a file ID to its corresponding URL by prepending the mask prefix.\r\n   * Handles cases where the mask may or may not end with a slash.\r\n   *\r\n   * @param id - The file ID to convert to a URL.\r\n   * @returns The constructed URL string for the given file ID.\r\n   */\r\n  const idToUrl = (id: sfsFileId) =>\r\n    (mask.endsWith(\"/\") ? mask : mask + \"/\") + id;\r\n\r\n  /**\r\n   * Resolves the absolute file system path and original name of a stored file by its ID.\r\n   *\r\n   * This function retrieves metadata for the given file ID using `getFileById`,\r\n   * and constructs the full path to the file in the `publicFolder`, based on its hash and extension.\r\n   *\r\n   * @param id - The unique identifier of the stored file.\r\n   * @returns An object containing the full file system path (`filePath`) and original file name (`fileName`),\r\n   *          or `undefined` if the file was not found.\r\n   */\r\n  const resolveFilePath = async (id: sfsFileId) => {\r\n    try {\r\n      const fileInfo = await getFileById(id);\r\n      const { hash, extension, name } = fileInfo;\r\n      const filePath = hash + extension;\r\n      return { filePath: path.join(publicFolder, filePath), fileName: name };\r\n    } catch (err) {\r\n      logger && logger(err, \"error\");\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles upload and deduplication logic for a single file.\r\n   *\r\n   * - Calculates SHA-256 hash of the file content in-memory.\r\n   * - Determines file extension from name or infers from binary data.\r\n   * - Avoids storing duplicates by using `hash + extension` as unique filename.\r\n   * - Saves file to disk if not already stored.\r\n   * - Registers file metadata via `createFile`, or reuses existing entry.\r\n   *\r\n   * @param file - Uploaded file object (e.g., from express-fileupload).\r\n   * @param filePath - Logical file path (or folder-relative path) for storing metadata.\r\n   * @returns An `sfsFile` object with generated ID and public URL.\r\n   *\r\n   * @throws Will throw if file saving or metadata operations fail.\r\n   */\r\n\r\n  // TODO | ALL properties other than file shouls be optional\r\n  // TODO | Reimplement temp folder for hash calculation\r\n  // TODO | Support user defined hashing methods\r\n\r\n  const saveFile = async (\r\n    file: UploadedFile,\r\n    filePath: string = \"/\",\r\n    id: sfsFileId = uid()\r\n  ) => {\r\n    try {\r\n      // Save file\r\n      const name = decodeURI(file.name);\r\n      const hash = createHash(\"sha256\").update(file.data).digest(\"hex\");\r\n      // Get extenison\r\n      let extension = \"\";\r\n      const extensionFromName = path.extname(name);\r\n      if (extensionFromName) {\r\n        extension = extensionFromName;\r\n      } else {\r\n        const filetype = await fileTypeFromBuffer(file.data);\r\n        if (filetype) {\r\n          extension = `.${filetype.ext}`;\r\n        }\r\n      }\r\n      // Filename is its hash + extension to avoid storing duplicate files with different names\r\n      const constPath = path.join(publicFolder, hash + extension);\r\n      let fileInfo = await getFileByHash(hash);\r\n\r\n      // File exists\r\n      if (fileInfo) {\r\n        logger && logger(\"SFS: File already uploaded\", \"info\");\r\n      }\r\n      // File is new\r\n      else {\r\n        logger && logger(\"SFS: Saving file\", \"success\");\r\n        await file.mv(constPath);\r\n      }\r\n      // File is new or doesnt exist in this folder or duplocates are allowed\r\n      if (!!!fileInfo || filePath !== fileInfo.path || allowDuplicates) {\r\n        const size = fileInfo?.size || fs.statSync(constPath).size;\r\n        const type = fileInfo?.type || dotExtensionToCategotry(extension);\r\n        const now = Date.now();\r\n        const fileData = {\r\n          id,\r\n          name,\r\n          extension,\r\n          hash,\r\n          size,\r\n          type,\r\n          last_modified: now,\r\n          path: filePath,\r\n          publishedAt: now,\r\n        };\r\n\r\n        const mutationResult = await createFile(fileData);\r\n\r\n        mutationResult.url = idToUrl(mutationResult.id);\r\n\r\n        return mutationResult;\r\n      }\r\n\r\n      // File exists in this folder\r\n      else {\r\n        logger && logger(\"File already exists at this location\", \"error\");\r\n        fileInfo.url = idToUrl(fileInfo.id);\r\n\r\n        return fileInfo;\r\n      }\r\n    } catch (err) {\r\n      logger && logger(\"Upload error\", \"error\");\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const deleteFileByHash = async (hash: string) => {\r\n    try {\r\n      const files = fs.readdirSync(publicFolder);\r\n      const fileToDelete = files.find((f) => f.split(\".\")[0] === hash);\r\n      if (!fileToDelete) {\r\n        throw new Error(`File with hash ${hash} not found in ${publicFolder}`);\r\n      }\r\n      const pathToFile = path.join(publicFolder, fileToDelete);\r\n      fs.unlinkSync(pathToFile);\r\n    } catch (err) {\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const deleteFileById = async (id: string) => {\r\n    try {\r\n      const { filePath } = await resolveFilePath(id);\r\n      fs.unlinkSync(filePath);\r\n    } catch (err) {\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const getDiskUsage = async (req, res) => {\r\n    const diskSpace = await checkDiskSpace(publicFolder);\r\n    return diskSpace;\r\n  };\r\n  return {\r\n    resolveFilePath,\r\n    idToUrl,\r\n    urlToId,\r\n    saveFile,\r\n    deleteFileByHash,\r\n    deleteFileById,\r\n    getDiskUsage,\r\n  };\r\n}\r\n"],"names":["initFunctions","_ref","publicFolder","mask","getFileById","getFileByHash","createFile","_ref$logger","logger","undefined","_ref$uid","uid","uuidv4","_ref$allowDuplicates","allowDuplicates","idToUrl","id","endsWith","resolveFilePath","Promise","resolve","_catch","then","fileInfo","name","filePath","path","join","hash","extension","fileName","err","e","reject","urlToId","url","replace","saveFile","file","_temp4","constPath","_temp2","size","fs","statSync","type","dotExtensionToCategotry","now","Date","last_modified","publishedAt","mutationResult","_temp","mv","decodeURI","createHash","update","data","digest","extensionFromName","extname","_temp3","fileTypeFromBuffer","filetype","ext","Error","deleteFileByHash","fileToDelete","readdirSync","find","f","split","pathToFile","unlinkSync","deleteFileById","_ref2","getDiskUsage","req","res","checkDiskSpace"],"mappings":"kUA2GwB,SAAAA,EAAaC,GACnC,IAAAC,EAAYD,EAAZC,aACAC,EAAIF,EAAJE,KACAC,EAAWH,EAAXG,YACAC,EAAaJ,EAAbI,cACAC,EAAUL,EAAVK,WAAUC,EAAAN,EACVO,OAAAA,OAAM,IAAAD,OAAGE,EAASF,EAAAG,EAAAT,EAClBU,IAAAA,OAAMC,IAAHF,EAAGE,EAAMF,EAAAG,EAAAZ,EACZa,gBAAAA,OAAkB,IAAHD,GAAQA,EAmBjBE,EAAU,SAACC,GACf,OAACb,EAAKc,SAAS,KAAOd,EAAOA,EAAO,KAAOa,CAAE,EAYzCE,EAAA,SAAyBF,GAAiB,IAAA,OAAAG,QAAAC,QAAAC,EAAA,WAC1CF,OAAAA,QAAAC,QACqBhB,EAAYY,IAAGM,KAAhCC,SAAAA,GACN,IAAyBC,EAASD,EAATC,KAEzB,MAAO,CAAEC,SAAUC,EAAKC,KAAKzB,EAFKqB,EAA1BK,KAA0BL,EAApBM,WAEwCC,SAAUN,EAAO,EACxE,EAAQO,SAAAA,GACPvB,GAAUA,EAAOuB,EAAK,QACvB,GACH,CAAC,MAAAC,GAAA,OAAAb,QAAAc,OAAAD,EAsBD,CAAA,EA8FA,MAAO,CACLd,gBAAAA,EACAH,QAAAA,EACAmB,QAvJc,SAACC,UACfhC,EAAKc,SAAS,KAAOkB,EAAIC,QAAQjC,EAAM,IAAMgC,EAAIC,QAAQjC,EAAO,IAAK,GAAG,EAuJxEkC,SAlGI,SACJC,EACAb,EACAT,QADmB,IAAnBS,IAAAA,EAAmB,KAAG,gBACtBhB,IAAAO,IAAAA,EAAgBL,KAAKQ,QAAAC,QAAAC,EAAA,WAEjBkB,SAAAA,IAgBF,IAAMC,EAAYd,EAAKC,KAAKzB,EAAc0B,EAAOC,GAAW,OAAAV,QAAAC,QACvCf,EAAcuB,IAAKN,KAApCC,SAAAA,GAAQkB,SAAAA,IAYR,IAAGlB,GAAYE,IAAaF,EAASG,MAAQZ,EAAe,CAC9D,IAAM4B,GAAOnB,MAAAA,OAAAA,EAAAA,EAAUmB,OAAQC,EAAGC,SAASJ,GAAWE,KAChDG,GAAe,MAARtB,OAAQ,EAARA,EAAUsB,OAAQC,EAAwBjB,GACjDkB,EAAMC,KAAKD,MAWf,OAAA5B,QAAAC,QAE2Bd,EAZZ,CACfU,GAAAA,EACAQ,KAAAA,EACAK,UAAAA,EACAD,KAAAA,EACAc,KAAAA,EACAG,KAAAA,EACAI,cAAeF,EACfrB,KAAMD,EACNyB,YAAaH,KAGkCzB,KAAA,SAA3C6B,GAIN,OAFAA,EAAehB,IAAMpB,EAAQoC,EAAenC,IAErCmC,CAAe,EAAA,CAQtB,OAHA3C,GAAUA,EAAO,uCAAwC,SACzDe,EAASY,IAAMpB,EAAQQ,EAASP,IAEzBO,CAAS6B,CAAAA,IAAAA,EArCd7B,WAAAA,IAAAA,EAK8C,OAAhDf,GAAUA,EAAO,mBAAoB,WAAWW,QAAAC,QAC1CkB,EAAKe,GAAGb,IAAUlB,KAAA,WAAA,GALxBd,GAAUA,EAAO,6BAA8B,OAKvB,CANtBe,GAMsB,OAAA6B,GAAAA,EAAA9B,KAAA8B,EAAA9B,KAAAmB,GAAAA,GAAA,EAAA,CAxB1B,IAAMjB,EAAO8B,UAAUhB,EAAKd,MACtBI,EAAO2B,EAAW,UAAUC,OAAOlB,EAAKmB,MAAMC,OAAO,OAEvD7B,EAAY,GACV8B,EAAoBjC,EAAKkC,QAAQpC,GAAMqC,EACzCF,WAAAA,IAAAA,EAC4BxC,OAAAA,QAAAC,QAEP0C,EAAmBxB,EAAKmB,OAAKnC,KAA9CyC,SAAAA,GACFA,IACFlC,EAAgBkC,IAAAA,EAASC,IAAMH,GAJjChC,EAAY8B,CAIqBE,CAL/BF,GAK+BE,OAAAA,GAAAA,EAAAvC,KAAAuC,EAAAvC,KAAAiB,GAAAA,GA+CpC,EAAA,SAAQR,GAEP,MADAvB,GAAUA,EAAO,eAAgB,SAC3B,IAAIyD,MAAMlC,EACjB,GACH,CAAC,MAAAC,UAAAb,QAAAc,OAAAD,EAAA,CAAA,EA+BCkC,iBA9BoB,SAAUtC,OAC9B,IACE,IACMuC,EADQxB,EAAGyB,YAAYlE,GACFmE,KAAK,SAACC,GAAC,OAAKA,EAAEC,MAAM,KAAK,KAAO3C,CAAI,GAC/D,IAAKuC,EACH,UAAUF,MAAwBrC,kBAAAA,EAAqB1B,iBAAAA,GAEzD,IAAMsE,EAAa9C,EAAKC,KAAKzB,EAAciE,GAC3CxB,EAAG8B,WAAWD,EACf,CAAC,MAAOzC,GACP,MAAU,IAAAkC,MAAMlC,EACjB,CAAA,OAAAZ,QAAAC,SACH,CAAC,MAAAY,GAAA,OAAAb,QAAAc,OAAAD,EAAA,CAAA,EAmBC0C,eAlBkB,SAAU1D,GAAU,IAAIG,OAAAA,QAAAC,QAAAC,EACtC,WAAA,OAAAF,QAAAC,QACyBF,EAAgBF,IAAGM,KAAAqD,SAAAA,GAC9ChC,EAAG8B,WADaE,EAARlD,SACgB,EACzB,EAAA,SAAQM,GACP,MAAU,IAAAkC,MAAMlC,EACjB,GACH,CAAC,MAAAC,GAAA,OAAAb,QAAAc,OAAAD,EAAA,CAAA,EAYC4C,aAXI,SAAsBC,EAAKC,GAAG,IAAI3D,OAAAA,QAAAC,QACd2D,EAAe7E,GAEzC,CAAC,MAAA8B,GAAA,OAAAb,QAAAc,OAAAD,EAAA,CAAA,EAUH"}