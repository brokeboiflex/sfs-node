{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import fs from \"fs\";\r\nimport path from \"path\";\r\nimport checkDiskSpace from \"check-disk-space\";\r\nimport { createHash } from \"crypto\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { dotExtensionToCategotry, sfsFileType } from \"sfs-file-type\";\r\nimport { fileTypeFromBuffer } from \"file-type\";\r\n\r\nexport interface UploadedFile {\r\n  /** file name */\r\n  name: string;\r\n  /** A function to move the file elsewhere on your server */\r\n  mv(path: string, callback: (err: any) => void): void;\r\n  mv(path: string): Promise<void>;\r\n  /** Encoding type of the file */\r\n  encoding: string;\r\n  /** The mimetype of your file */\r\n  mimetype: string;\r\n  /** A buffer representation of your file, returns empty buffer in case useTempFiles option was set to true. */\r\n  data: Buffer;\r\n  /** Uploaded size in bytes */\r\n  size: number;\r\n  /** MD5 checksum of the uploaded file */\r\n  md5: string;\r\n}\r\nexport type sfsFileId = string | number;\r\nexport type sfsFile = {\r\n  id: sfsFileId;\r\n  name: string;\r\n  extension: string;\r\n  hash: string;\r\n  size: number; //Bytes\r\n  type: sfsFileType;\r\n  last_modified: number; //timestamp,\r\n  path: string;\r\n  url?: string;\r\n};\r\nexport type loggerLvl = \"info\" | \"success\" | \"error\";\r\n/**\r\n * Configuration for Simple File Storage (SFS)\r\n */\r\nexport type sfsConfig = {\r\n  /**\r\n   * Folder where files will be stored.\r\n   */\r\n  publicFolder: string;\r\n\r\n  /**\r\n   * Base URL prefix to which the file ID will be appended.\r\n   */\r\n  mask: string;\r\n\r\n  /**\r\n   * Function that returns an `sfsFile` based on its ID.\r\n   * @param id - The file's unique identifier.\r\n   * @returns A promise resolving to the corresponding `sfsFile`.\r\n   */\r\n  getFileById: (id: sfsFileId) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Function that returns an `sfsFile` based on its content hash.\r\n   * @param hash - The hash of the file contents.\r\n   * @returns A promise resolving to the corresponding `sfsFile`.\r\n   */\r\n  getFileByHash: (hash: string) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Function that stores an `sfsFile` and returns the stored object.\r\n   * @param file - The `sfsFile` to be created.\r\n   * @returns A promise resolving to the stored `sfsFile`.\r\n   */\r\n  createFile: (file: sfsFile) => Promise<sfsFile>;\r\n\r\n  /**\r\n   * Optional logger function. Leave undefined to disable logging.\r\n   * @param message - Log message or object.\r\n   * @param lvl - Optional log level (e.g., info, warn, error).\r\n   */\r\n  logger?: (message: any, lvl?: loggerLvl) => void;\r\n\r\n  /**\r\n   * Optional function for generating unique IDs.\r\n   * Defaults to `uuidv4()` if not provided.\r\n   * @returns A unique string or number.\r\n   */\r\n  uid?: () => string | number;\r\n};\r\n\r\n/**\r\n * Initializes core logic functions for the Simple File Storage (SFS) system.\r\n *\r\n * @param config - The configuration object for the SFS system.\r\n * @param config.publicFolder - Path to the folder where uploaded files will be stored.\r\n * @param config.mask - Base URL prefix for constructing public file URLs (e.g., \"https://example.com/files\").\r\n * @param config.getFileById - Async function that retrieves an `sfsFile` by its unique ID.\r\n * @param config.getFileByHash - Async function that retrieves an `sfsFile` by its content hash.\r\n * @param config.createFile - Async function that stores an `sfsFile` and returns the stored object.\r\n * @param config.logger - Optional logger function for internal operations. No logging if undefined.\r\n * @param config.uid - Optional function for generating unique IDs (defaults to `uuidv4` if not provided).\r\n *\r\n * @returns An object containing internal logic functions used by the SFS system.\r\n */\r\nexport default function initFunctions({\r\n  publicFolder,\r\n  mask,\r\n  getFileById,\r\n  getFileByHash,\r\n  createFile,\r\n  logger,\r\n  uid = uuidv4,\r\n}: sfsConfig) {\r\n  /**\r\n   * Converts a URL to its corresponding file ID by removing the mask prefix.\r\n   * Handles cases where the mask may or may not end with a slash.\r\n   *\r\n   * @param url - The URL string to convert.\r\n   * @returns The extracted file ID from the URL.\r\n   */\r\n  const urlToId = (url: string) =>\r\n    mask.endsWith(\"/\") ? url.replace(mask, \"\") : url.replace(mask + \"/\", \"\");\r\n\r\n  /**\r\n   * Converts a file ID to its corresponding URL by prepending the mask prefix.\r\n   * Handles cases where the mask may or may not end with a slash.\r\n   *\r\n   * @param id - The file ID to convert to a URL.\r\n   * @returns The constructed URL string for the given file ID.\r\n   */\r\n  const idToUrl = (id: sfsFileId) =>\r\n    (mask.endsWith(\"/\") ? mask : mask + \"/\") + id;\r\n\r\n  /**\r\n   * Resolves the absolute file system path and original name of a stored file by its ID.\r\n   *\r\n   * This function retrieves metadata for the given file ID using `getFileById`,\r\n   * and constructs the full path to the file in the `publicFolder`, based on its hash and extension.\r\n   *\r\n   * @param id - The unique identifier of the stored file.\r\n   * @returns An object containing the full file system path (`filePath`) and original file name (`fileName`),\r\n   *          or `undefined` if the file was not found.\r\n   */\r\n  const resolveFilePath = async (id: sfsFileId) => {\r\n    const fileInfo = await getFileById(id);\r\n    if (fileInfo) {\r\n      const { hash, extension, name } = fileInfo;\r\n      const filePath = hash + extension;\r\n      return { filePath: path.join(publicFolder, filePath), fileName: name };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles upload and deduplication logic for a single file.\r\n   *\r\n   * - Calculates SHA-256 hash of the file content in-memory.\r\n   * - Determines file extension from name or infers from binary data.\r\n   * - Avoids storing duplicates by using `hash + extension` as unique filename.\r\n   * - Saves file to disk if not already stored.\r\n   * - Registers file metadata via `createFile`, or reuses existing entry.\r\n   *\r\n   * @param file - Uploaded file object (e.g., from express-fileupload).\r\n   * @param filePath - Logical file path (or folder-relative path) for storing metadata.\r\n   * @returns An `sfsFile` object with generated ID and public URL.\r\n   *\r\n   * @throws Will throw if file saving or metadata operations fail.\r\n   */\r\n  const saveFile = async (file: UploadedFile, filePath: string) => {\r\n    try {\r\n      // Save file\r\n      const name = decodeURI(file.name);\r\n      const hash = createHash(\"sha256\").update(file.data).digest(\"hex\");\r\n      // Get extenison\r\n      let extension = \"\";\r\n      const extensionFromName = path.extname(name);\r\n      if (extensionFromName) {\r\n        extension = extensionFromName;\r\n      } else {\r\n        const filetype = await fileTypeFromBuffer(file.data);\r\n        if (filetype) {\r\n          extension = `.${filetype.ext}`;\r\n        }\r\n      }\r\n      // Filename is its hash + extension to avoid storing duplicate files with different names\r\n      const constPath = path.join(publicFolder, hash + extension);\r\n      let fileInfo = await getFileByHash(hash);\r\n\r\n      // File exists\r\n      if (fileInfo) {\r\n        logger(\"SFS: File already uploaded\", \"info\");\r\n      }\r\n      // File is new\r\n      else {\r\n        logger(\"SFS: Saving file\", \"success\");\r\n        await file.mv(constPath);\r\n      }\r\n      // File is new or doesnt exist in this folder\r\n      if (!!!fileInfo || filePath !== fileInfo.path) {\r\n        const size = fileInfo?.size || fs.statSync(constPath).size;\r\n        const type = fileInfo?.type || dotExtensionToCategotry(extension);\r\n\r\n        const fileData = {\r\n          id: uid(),\r\n          name,\r\n          extension,\r\n          hash,\r\n          size,\r\n          type,\r\n          last_modified: Date.now(),\r\n          path: filePath,\r\n          publishedAt: Date.now(),\r\n        };\r\n\r\n        const mutationResult = await createFile(fileData);\r\n\r\n        mutationResult.url = idToUrl(mutationResult.id);\r\n\r\n        return mutationResult;\r\n      }\r\n\r\n      // File exists in this folder\r\n      else {\r\n        logger(\"File already exists at this location\", \"error\");\r\n        fileInfo.url = idToUrl(fileInfo.id);\r\n\r\n        return fileInfo;\r\n      }\r\n    } catch (err) {\r\n      logger(\"Upload error\", \"error\");\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const deleteFileByHash = async (hash: string) => {\r\n    try {\r\n      const files = fs.readdirSync(publicFolder);\r\n      const fileToDelete = files.find((f) => f.split(\".\")[0] === hash);\r\n      if (!fileToDelete) {\r\n        throw new Error(`File with hash ${hash} not found in ${publicFolder}`);\r\n      }\r\n      const pathToFile = path.join(publicFolder, fileToDelete);\r\n      fs.unlinkSync(pathToFile);\r\n    } catch (err) {\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const deleteFileById = async (id: string) => {\r\n    try {\r\n      const { filePath } = await resolveFilePath(id);\r\n      const pathToFile = path.join(publicFolder, filePath);\r\n      fs.unlinkSync(pathToFile);\r\n    } catch (err) {\r\n      throw new Error(err);\r\n    }\r\n  };\r\n  const getDiskUsage = async (req, res) => {\r\n    const diskSpace = await checkDiskSpace(publicFolder);\r\n    return diskSpace;\r\n  };\r\n  return {\r\n    resolveFilePath,\r\n    idToUrl,\r\n    urlToId,\r\n    saveFile,\r\n    deleteFileByHash,\r\n    deleteFileById,\r\n    getDiskUsage,\r\n  };\r\n}\r\n"],"names":["_ref","publicFolder","mask","getFileById","getFileByHash","createFile","logger","_ref$uid","uid","uuidv4","v4","idToUrl","id","endsWith","resolveFilePath","Promise","resolve","then","fileInfo","name","filePath","path","join","hash","extension","fileName","e","reject","urlToId","url","replace","saveFile","file","_catch","_temp4","constPath","_temp2","size","fs","statSync","type","dotExtensionToCategotry","fileData","last_modified","Date","now","publishedAt","mutationResult","_temp","mv","decodeURI","createHash","update","data","digest","extensionFromName","extname","_temp3","fileTypeFromBuffer","filetype","ext","err","Error","deleteFileByHash","fileToDelete","readdirSync","find","f","split","pathToFile","unlinkSync","deleteFileById","_ref2","getDiskUsage","req","res","checkDiskSpace"],"mappings":"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"}